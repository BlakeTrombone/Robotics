#pragma config(Sensor, dgtl1,  fleft,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  fright,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  bleft,          sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  bright,         sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  spinner,        sensorQuadEncoder)
#pragma config(Motor,  port2,           right,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           left,          tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           right,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           left,          tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           claw,          tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           spinner,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           push,          tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           arm,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          back,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void clear() //clears encoders
{
	SensorValue[fleft] = 0;
  SensorValue[fright] = 0;
  SensorValue[bleft] = 0;
  SensorValue[bright] = 0;
	SensorValue[spinner] = 0;
}

void drive(int distance)
{
	clear(); //clears encoders for accurate measurments
	int dist = distance / 5*PI; //finds the distance from degrees for the wheels
	while ((((SensorValue[fleft]+SensorValue[fright])/2)+((SensorValue[fleft]+SensorValue[fright])/2))/2< dist)//while the sensors have a lower value than the distance
	{
		motor[left] = 127;//left motors full speed forward
		motor[right] = 127;// right motors full speed forward

		if ((SensorValue[fleft] + SensorValue[bleft])/2<(SensorValue[fright]+SensorValue[bright])/2)//if the average left encoders are less than the average of the right encoders...
			if (motor[left]>=123)//... and the left motor is running full speed...
				motor[right] = motor[right] - 5;//... lower the right motor speed
		  else motor[left] = motor[left] + 5;//if the left motor isn't running full speed, raise it up a notch.

		if ((SensorValue[fleft] + SensorValue[bleft])/2>(SensorValue[fright]+SensorValue[bright])/2)//if the average right encoders are less than the average of the left encoders...
			if (motor[right]>=123)//... and the right motor is running full speed...
				motor[left] = motor[left] - 5;//... lower the left motor speed
		  else motor[right] = motor[right] + 5;//if the right motor isn't running full speed, raise it up a notch.

	}
}


void turn(int degrees)
{
	clear();//clears encoders for accurate measurments
	int cos = (degrees/360) * 0 * PI; //REPLACE 0 WITH ROBOT WIDTH (DIAMETER)
	if (degrees < 0)
		while ((SensorValue[fleft]+SensorValue[bleft])/2-(SensorValue[fright]+SensorValue[bright])/2<cos)
		{
			motor[left] = -127;
			motor[right] = 127;
		}

	if (degrees > 0)
		while ((SensorValue[fleft]+SensorValue[bleft])/2-(SensorValue[fright]+SensorValue[bright])/2>cos)
		{
			motor[left] = 127;
			motor[right] = -127;
		}
}

void spin(int degrees)
{
	clear();
	if (degrees < 0)
		while (degrees <SensorValue[spinner])
			motor[spinner] = -127;
	if (degrees > 0)
		while (degrees > SensorValue[spinner])
			motor[spinner] = 127;
}



task main ()
{
	clear();
  while(1 == 1)
  {
    motor[left]  = (vexRT[Ch2] + vexRT[Ch1])/2;
    motor[right] = (vexRT[Ch2] - vexRT[Ch1])/2;
    motor[spinner] = vexRT[Ch1];
    motor[claw] = vexRT[Ch2];
  }
}
